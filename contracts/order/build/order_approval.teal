#pragma version 10
//tealish version git+https://github.com/tinymanorg/tealish.git@d7441973671cf6b79dd55843016892f4b86ceeba

// Tinyman Order Protocol
// License: https://github.com/tinymanorg/tinyman-order-protocol/blob/main/LICENSE
// Documentation: https://docs.tinyman.org


// Name: o<id>


// Global State

#define REGISTRY_APP_ID_KEY "registry_app_id"
#define REGISTRY_APP_ACCOUNT_ADDRESS_KEY "registry_app_account_address"
#define VAULT_APP_ID_KEY "vault_app_id"
#define ORDER_FEE_RATE_KEY "order_fee_rate"
#define GOVERNOR_ORDER_FEE_RATE_KEY "governor_order_fee_rate"
#define GOVERNOR_FEE_RATE_POWER_THRESHOLD "governor_fee_rate_power_threshold"

#define USER_ADDRESS_KEY "user_address"
#define TOTAL_ORDER_COUNT_KEY "order_count"

#define PROPOSED_MANAGER_KEY "proposed_manager"
#define MANAGER_KEY "manager"

#define ORDER_FEE_RATE_KEY "order_fee_rate"

// Math Constants

#define RATE_SCALER 18446744073709551615
#define MAX_UINT64 18446744073709551615


// tl:48: router:
pushbytes "create_application"
pushbytes "update_application"
pushbytes "init"
pushbytes "propose_manager"
pushbytes "accept_manager"
pushbytes "asset_opt_in"
pushbytes "put_order"
pushbytes "cancel_order"
pushbytes "start_execute_order"
pushbytes "end_execute_order"
pushbytes "collect"
txna ApplicationArgs 0
match route_create_application route_update_application route_init route_propose_manager route_accept_manager route_asset_opt_in route_put_order route_cancel_order route_start_execute_order route_end_execute_order route_collect
err                                                         // unexpected value
route_create_application:
    txn ApplicationID; pushint 0; ==; assert                // ApplicationID == 0
    txna ApplicationArgs 1; btoi 
    txna ApplicationArgs 2; btoi 
    txna ApplicationArgs 3; dup; len; pushint 32; ==; assert// Bytes Size Assertion: 32 bytes
    callsub __func__create_application
    pushint 1; return
route_update_application:
    txn OnCompletion; pushint 4; ==; assert                 // assert OnCompletion == UpdateApplication
    callsub __func__update_application
    pushint 1; return
route_init:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__init
    pushint 1; return
route_propose_manager:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; dup; len; pushint 32; ==; assert// Bytes Size Assertion: 32 bytes
    callsub __func__propose_manager
    pushint 1; return
route_accept_manager:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__accept_manager
    pushint 1; return
route_asset_opt_in:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; dup; len; pushint 64; ==; assert// Bytes Size Assertion: 64 bytes
    callsub __func__asset_opt_in
    pushint 1; return
route_put_order:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    txna ApplicationArgs 2; btoi 
    txna ApplicationArgs 3; btoi 
    txna ApplicationArgs 4; btoi 
    txna ApplicationArgs 5; btoi 
    txna ApplicationArgs 6; btoi 
    callsub __func__put_order
    pushint 1; return
route_cancel_order:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    callsub __func__cancel_order
    pushint 1; return
route_start_execute_order:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    txna ApplicationArgs 2; btoi 
    txna ApplicationArgs 3; btoi 
    callsub __func__start_execute_order
    pushint 1; return
route_end_execute_order:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    txna ApplicationArgs 2; btoi 
    txna ApplicationArgs 3; btoi 
    callsub __func__end_execute_order
    pushint 1; return
route_collect:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    callsub __func__collect
    pushint 1; return


// Permission: anyone
// tl:65: func create_application(registry_app_id: int, vault_app_id: int, manager_address: bytes[32]):
__func__create_application:
    store 1                                                 // manager_address [bytes[32]]
    store 2                                                 // vault_app_id [int]
    store 3                                                 // registry_app_id [int]
    // tl:66: app_global_put(USER_ADDRESS_KEY, Txn.Sender)
    pushbytes USER_ADDRESS_KEY                              // "user_address"
    txn Sender
    app_global_put
    // tl:67: app_global_put(MANAGER_KEY, manager_address)
    pushbytes MANAGER_KEY                                   // "manager"
    load 1                                                  // manager_address
    app_global_put
    
    // tl:69: app_global_put(REGISTRY_APP_ID_KEY, registry_app_id)
    pushbytes REGISTRY_APP_ID_KEY                           // "registry_app_id"
    load 3                                                  // registry_app_id
    app_global_put
    // tl:70: bytes registry_app_account_address [slot 4]
    // tl:71: _, registry_app_account_address = app_params_get(AppAddress, registry_app_id)
    load 3                                                  // registry_app_id
    app_params_get AppAddress
    pop                                                     // discarding value for _
    store 4                                                 // registry_app_account_address
    // tl:72: app_global_put(REGISTRY_APP_ACCOUNT_ADDRESS_KEY, registry_app_account_address)
    pushbytes REGISTRY_APP_ACCOUNT_ADDRESS_KEY              // "registry_app_account_address"
    load 4                                                  // registry_app_account_address
    app_global_put
    // tl:73: app_global_put(VAULT_APP_ID_KEY, vault_app_id)
    pushbytes VAULT_APP_ID_KEY                              // "vault_app_id"
    load 2                                                  // vault_app_id
    app_global_put
    
    // create_application(user_address,registry_app_id,vault_app_id,manager_address)
    // tl:76: log(ARC28Event("create_application(address,uint64,uint64,address)", Txn.Sender, itob(registry_app_id), itob(vault_app_id), manager_address))
    pushbytes 0x9cf7b48c                                    // SHA512_256("create_application(address,uint64,uint64,address)")[:4]
    txn Sender
    load 3                                                  // registry_app_id
    itob
    load 2                                                  // vault_app_id
    itob
    load 1                                                  // manager_address
    concat
    concat
    concat
    concat
    log
    // tl:77: return
    retsub


// TODO: Remove function for mainnet
// tl:83: func update_application():
__func__update_application:
    // tl:84: assert(Txn.Sender == app_global_get("manager"))
    txn Sender
    pushbytes "manager"
    app_global_get
    ==
    assert
    // tl:85: return
    retsub


// Permission: manager
// tl:91: func init():
__func__init:
    // tl:92: assert(Txn.Sender == app_global_get(MANAGER_KEY))
    txn Sender
    pushbytes MANAGER_KEY                                   // "manager"
    app_global_get
    ==
    assert
    
    // tl:94: log(ARC28Event("init()"))
    pushbytes 0x8707a1db                                    // SHA512_256("init()")[:4]
    log
    // tl:95: return
    retsub


// permission: manager
// tl:101: func propose_manager(new_manager: bytes[32]):
__func__propose_manager:
    store 5                                                 // new_manager [bytes[32]]
    // tl:102: assert(Txn.Sender == app_global_get(MANAGER_KEY))
    txn Sender
    pushbytes MANAGER_KEY                                   // "manager"
    app_global_get
    ==
    assert
    
    // tl:104: app_global_put(PROPOSED_MANAGER_KEY, new_manager)
    pushbytes PROPOSED_MANAGER_KEY                          // "proposed_manager"
    load 5                                                  // new_manager
    app_global_put
    // tl:105: log(ARC28Event("propose_manager(address)", new_manager))
    pushbytes 0x9f8a67ff                                    // SHA512_256("propose_manager(address)")[:4]
    load 5                                                  // new_manager
    concat
    log
    // tl:106: return
    retsub


// The proposed manager must call this function to become the manager.
// permission: proposed_manager
// tl:113: func accept_manager():
__func__accept_manager:
    // tl:114: bytes proposed_manager = app_global_get(PROPOSED_MANAGER_KEY) [slot 6]
    pushbytes PROPOSED_MANAGER_KEY                          // "proposed_manager"
    app_global_get
    store 6                                                 // proposed_manager
    // tl:115: assert(Txn.Sender == proposed_manager)
    txn Sender
    load 6                                                  // proposed_manager
    ==
    assert
    
    // tl:117: app_global_put(MANAGER_KEY, proposed_manager)
    pushbytes MANAGER_KEY                                   // "manager"
    load 6                                                  // proposed_manager
    app_global_put
    // tl:118: app_global_put(PROPOSED_MANAGER_KEY, "")
    pushbytes PROPOSED_MANAGER_KEY                          // "proposed_manager"
    pushbytes ""
    app_global_put
    // tl:119: log(ARC28Event("accept_manager(address)", proposed_manager))
    pushbytes 0xbb6affe3                                    // SHA512_256("accept_manager(address)")[:4]
    load 6                                                  // proposed_manager
    concat
    log
    // tl:120: return
    retsub


// tl:125: func asset_opt_in(asset_ids: int[8]):
__func__asset_opt_in:
    store 7                                                 // asset_ids [int[8]]
    // tl:126: bytes user_address = app_global_get(USER_ADDRESS_KEY) [slot 8]
    pushbytes USER_ADDRESS_KEY                              // "user_address"
    app_global_get
    store 8                                                 // user_address
    // tl:127: assert(Txn.Sender == user_address)
    txn Sender
    load 8                                                  // user_address
    ==
    assert
    
    // Required Algo to cover minimum balance increase must be supplied.
    // It is not checked explicitly.
    // Using extra balance is allowed.
    // tl:132: for i in 0:8:
        pushint 0
        store 9                                             // i
        l0_for:
        load 9                                              // i
        pushint 8
        ==
        bnz l0_end
        // tl:133: opt_in_to_asset_if_needed(asset_ids[i])
        load 7                                              // asset_ids
        pushint 8
        load 9                                              // i
        *
        pushint 8
        extract
        btoi
        callsub __func__opt_in_to_asset_if_needed
        load 9                                              // i
        pushint 1
        +
        store 9                                             // i
        b l0_for
        l0_end:
    // tl:135: return
    retsub


// Description: Create an order with the monotonically incremented ORDER_COUNT as id.
// Prerequisites: App should be opted into both `asset_id` and `target_asset_id`. Only `target_asset_id` optin checked explicitly.
// Permission: App owner (User)
// tl:143: func put_order(asset_id: int, amount: int, target_asset_id: int, target_amount: int, is_partial_allowed: int, duration: int):
__func__put_order:
    store 10                                                // duration [int]
    store 11                                                // is_partial_allowed [int]
    store 12                                                // target_amount [int]
    store 13                                                // target_asset_id [int]
    store 14                                                // amount [int]
    store 15                                                // asset_id [int]
    // tl:144: bytes user_address = app_global_get(USER_ADDRESS_KEY) [slot 16]
    pushbytes USER_ADDRESS_KEY                              // "user_address"
    app_global_get
    store 16                                                // user_address
    // tl:145: assert(Txn.Sender == user_address)
    txn Sender
    load 16                                                 // user_address
    ==
    assert
    
    // tl:147: int total_order_count = app_global_get(TOTAL_ORDER_COUNT_KEY) [slot 17]
    pushbytes TOTAL_ORDER_COUNT_KEY                         // "order_count"
    app_global_get
    store 17                                                // total_order_count
    // tl:148: box<Order> order = CreateBox(Concat("o", itob(total_order_count))) [slot 18]
    pushbytes "o"
    load 17                                                 // total_order_count
    itob
    concat
    dup; pushint 80; box_create; assert                     // create & assert created
    store 18                                                // box:order
    
    // Assertions
    // tl:151: assert(amount > 0)
    load 14                                                 // amount
    pushint 0
    >
    assert
    // tl:152: assert(target_amount > 0)
    load 12                                                 // target_amount
    pushint 0
    >
    assert
    // tl:153: assert(asset_id != target_asset_id)
    load 15                                                 // asset_id
    load 13                                                 // target_asset_id
    !=
    assert
    // tl:154: assert(duration > 0)
    load 10                                                 // duration
    pushint 0
    >
    assert
    
    // tl:156: int expiration_timestamp = Global.LatestTimestamp + duration [slot 19]
    global LatestTimestamp
    load 10                                                 // duration
    +
    store 19                                                // expiration_timestamp
    
    // tl:158: int is_opted_in_to_target [slot 20]
    // tl:159: is_opted_in_to_target, _ = asset_holding_get(AssetBalance, Global.CurrentApplicationAddress, target_asset_id)
    global CurrentApplicationAddress
    load 13                                                 // target_asset_id
    asset_holding_get AssetBalance
    store 20                                                // is_opted_in_to_target
    pop                                                     // discarding value for _
    // tl:160: assert(is_opted_in_to_target)
    load 20                                                 // is_opted_in_to_target
    assert
    
    // tl:162: check_received_asset(Txn.GroupIndex - 1, Global.CurrentApplicationAddress, asset_id, amount)
    txn GroupIndex
    pushint 1
    -
    global CurrentApplicationAddress
    load 15                                                 // asset_id
    load 14                                                 // amount
    callsub __func__check_received_asset
    
    // tl:164: int fee_rate = get_fee_rate() [slot 21]
    callsub __func__get_fee_rate
    store 21                                                // fee_rate
    
    // tl:166: order.asset_id = asset_id
    load 15                                                 // asset_id
    itob
    load 18
    pushint 0
    uncover 2
    box_replace
    // boxset order.asset_id
    // tl:167: order.amount = amount
    load 14                                                 // amount
    itob
    load 18
    pushint 8
    uncover 2
    box_replace
    // boxset order.amount
    // tl:168: order.target_asset_id = target_asset_id
    load 13                                                 // target_asset_id
    itob
    load 18
    pushint 16
    uncover 2
    box_replace
    // boxset order.target_asset_id
    // tl:169: order.target_amount = target_amount
    load 12                                                 // target_amount
    itob
    load 18
    pushint 24
    uncover 2
    box_replace
    // boxset order.target_amount
    // tl:170: order.filled_amount = 0
    pushint 0
    itob
    load 18
    pushint 32
    uncover 2
    box_replace
    // boxset order.filled_amount
    // tl:171: order.collected_target_amount = 0
    pushint 0
    itob
    load 18
    pushint 40
    uncover 2
    box_replace
    // boxset order.collected_target_amount
    // tl:172: order.is_partial_allowed = is_partial_allowed
    load 11                                                 // is_partial_allowed
    itob
    load 18
    pushint 48
    uncover 2
    box_replace
    // boxset order.is_partial_allowed
    // tl:173: order.fee_rate = fee_rate
    load 21                                                 // fee_rate
    itob
    load 18
    pushint 56
    uncover 2
    box_replace
    // boxset order.fee_rate
    // tl:174: order.creation_timestamp = Global.LatestTimestamp
    global LatestTimestamp
    itob
    load 18
    pushint 64
    uncover 2
    box_replace
    // boxset order.creation_timestamp
    // tl:175: order.expiration_timestamp = expiration_timestamp
    load 19                                                 // expiration_timestamp
    itob
    load 18
    pushint 72
    uncover 2
    box_replace
    // boxset order.expiration_timestamp
    
    // tl:177: app_global_put(TOTAL_ORDER_COUNT_KEY, total_order_count + 1)
    pushbytes TOTAL_ORDER_COUNT_KEY                         // "order_count"
    load 17                                                 // total_order_count
    pushint 1
    +
    app_global_put
    
    // Logs
    // tl:180: bytes order_data [slot 22]
    // tl:181: _, order_data = box_get(order)
    load 18                                                 // order
    box_get
    pop                                                     // discarding value for _
    store 22                                                // order_data
    // tl:182: log(ARC28Event("order(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)", user_address, itob(total_order_count), order_data))
    pushbytes 0xc953e07a                                    // SHA512_256("order(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)")[:4]
    load 16                                                 // user_address
    load 17                                                 // total_order_count
    itob
    load 22                                                 // order_data
    concat
    concat
    concat
    log
    // tl:183: log(ARC28Event("put_order(uint64)", itob(total_order_count)))
    pushbytes 0x1a736da3                                    // SHA512_256("put_order(uint64)")[:4]
    load 17                                                 // total_order_count
    itob
    concat
    log
    
    // tl:185: return
    retsub


// Description: Send the `amount` or `amount - filled_amount` if partially filled to the user. Delete the order box.
// Prerequisites: If partial filling is utilized, collect method must be called before.
// Permission: App owner (User)
// tl:193: func cancel_order(order_id: int):
__func__cancel_order:
    store 23                                                // order_id [int]
    // tl:194: bytes user_address = app_global_get(USER_ADDRESS_KEY) [slot 24]
    pushbytes USER_ADDRESS_KEY                              // "user_address"
    app_global_get
    store 24                                                // user_address
    // tl:195: assert(Txn.Sender == user_address)
    txn Sender
    load 24                                                 // user_address
    ==
    assert
    
    // tl:197: box<Order> order = OpenBox(Concat("o", itob(order_id))) [slot 25]
    pushbytes "o"
    load 23                                                 // order_id
    itob
    concat
    dup; box_len; assert; pushint 80; ==; assert            // len(box) == Order.size
    store 25                                                // box:order
    
    // It is assumed that the order is deleted once it is executed.
    // Send remaining amount back to user.
    
    // tl:202: int remaining_amount = order.amount [slot 26]
    load 25; pushint 8; pushint 8; box_extract; btoi// order.amount
    store 26                                                // remaining_amount
    // tl:203: if order.is_partial_allowed:
    load 25; pushint 48; pushint 8; box_extract; btoi// order.is_partial_allowed
    bz l1_end
    // then:
        // tl:204: remaining_amount = remaining_amount - order.filled_amount
        load 26                                             // remaining_amount
        load 25; pushint 32; pushint 8; box_extract; btoi// order.filled_amount
        -
        store 26                                            // remaining_amount
    l1_end:
    
    // tl:207: assert(!order.collected_target_amount)
    load 25; pushint 40; pushint 8; box_extract; btoi// order.collected_target_amount
    !
    assert
    
    // tl:209: transfer(order.asset_id, remaining_amount, Global.CurrentApplicationAddress, user_address)
    load 25; pushint 0; pushint 8; box_extract; btoi// order.asset_id
    load 26                                                 // remaining_amount
    global CurrentApplicationAddress
    load 24                                                 // user_address
    callsub __func__transfer
    
    // Logs
    // tl:212: bytes order_data [slot 27]
    // tl:213: _, order_data = box_get(order)
    load 25                                                 // order
    box_get
    pop                                                     // discarding value for _
    store 27                                                // order_data
    // tl:214: log(ARC28Event("order(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)", user_address, itob(order_id), order_data))
    pushbytes 0xc953e07a                                    // SHA512_256("order(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)")[:4]
    load 24                                                 // user_address
    load 23                                                 // order_id
    itob
    load 27                                                 // order_data
    concat
    concat
    concat
    log
    // tl:215: log(ARC28Event("cancel_order(uint64)", itob(order_id)))
    pushbytes 0xc69098a6                                    // SHA512_256("cancel_order(uint64)")[:4]
    load 23                                                 // order_id
    itob
    concat
    log
    
    // Delete the box.
    // tl:218: _ = box_del(order)
    load 25                                                 // order
    box_del
    pop                                                     // discarding value for _
    
    // tl:220: return
    retsub


// Description: Method allows an executor (taker) to do arbitrary operations between `Txn.GroupIndex < i < (Txn.GroupIndex + index_diff)`.
// An executor must call `end_execute_order` at the `Txn.GroupIndex + index_diff` for the transaction group to succeed.
// Permission: Everyone
// tl:228: func start_execute_order(order_id: int, fill_amount: int, index_diff: int):
__func__start_execute_order:
    store 28                                                // index_diff [int]
    store 29                                                // fill_amount [int]
    store 30                                                // order_id [int]
    // tl:229: box<Order> order = OpenBox(Concat("o", itob(order_id))) [slot 31]
    pushbytes "o"
    load 30                                                 // order_id
    itob
    concat
    dup; box_len; assert; pushint 80; ==; assert            // len(box) == Order.size
    store 31                                                // box:order
    
    // Assertions
    // tl:232: assert(index_diff >= 2)
    load 28                                                 // index_diff
    pushint 2
    >=
    assert
    
    // If partial filling is not allowed, executor should fill the whole order at once. Otherwise smaller amounts are allowed.
    // tl:235: int remaining_amount = order.amount [slot 32]
    load 31; pushint 8; pushint 8; box_extract; btoi// order.amount
    store 32                                                // remaining_amount
    // tl:236: if order.is_partial_allowed:
    load 31; pushint 48; pushint 8; box_extract; btoi// order.is_partial_allowed
    bz l2_else
    // then:
        // tl:237: remaining_amount = remaining_amount - order.filled_amount
        load 32                                             // remaining_amount
        load 31; pushint 32; pushint 8; box_extract; btoi// order.filled_amount
        -
        store 32                                            // remaining_amount
        // tl:238: assert(fill_amount <= remaining_amount)
        load 29                                             // fill_amount
        load 32                                             // remaining_amount
        <=
        assert
        b l2_end
    l2_else:
    // tl:239: else:
        // tl:240: assert(fill_amount == remaining_amount)
        load 29                                             // fill_amount
        load 32                                             // remaining_amount
        ==
        assert
    l2_end:
    
    // tl:243: assert(Global.LatestTimestamp <= order.expiration_timestamp)
    global LatestTimestamp
    load 31; pushint 72; pushint 8; box_extract; btoi// order.expiration_timestamp
    <=
    assert
    
    // tl:245: int end_execute_order_txn_index = Txn.GroupIndex + index_diff [slot 33]
    txn GroupIndex
    load 28                                                 // index_diff
    +
    store 33                                                // end_execute_order_txn_index
    // tl:246: assert(Gtxn[end_execute_order_txn_index].Sender == Txn.Sender)
    load 33                                                 // end_execute_order_txn_index
    gtxns Sender
    txn Sender
    ==
    assert
    // tl:247: assert(Gtxn[end_execute_order_txn_index].TypeEnum == Appl)
    load 33                                                 // end_execute_order_txn_index
    gtxns TypeEnum
    pushint 6                                               // Appl
    ==
    assert
    // tl:248: assert(Gtxn[end_execute_order_txn_index].OnCompletion == NoOp)
    load 33                                                 // end_execute_order_txn_index
    gtxns OnCompletion
    pushint 0                                               // NoOp
    ==
    assert
    // tl:249: assert(Gtxn[end_execute_order_txn_index].ApplicationID == Global.CurrentApplicationID)
    load 33                                                 // end_execute_order_txn_index
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    assert
    // tl:250: assert(Gtxn[end_execute_order_txn_index].ApplicationArgs[0] == "end_execute_order")
    load 33                                                 // end_execute_order_txn_index
    gtxnsa ApplicationArgs 0
    pushbytes "end_execute_order"
    ==
    assert
    // tl:251: assert(Gtxn[end_execute_order_txn_index].ApplicationArgs[1] == itob(order_id))
    load 33                                                 // end_execute_order_txn_index
    gtxnsa ApplicationArgs 1
    load 30                                                 // order_id
    itob
    ==
    assert
    // Parameters `fill_amount` and `index_diff` must be the same.
    // tl:253: assert(Gtxn[end_execute_order_txn_index].ApplicationArgs[2] == itob(fill_amount))
    load 33                                                 // end_execute_order_txn_index
    gtxnsa ApplicationArgs 2
    load 29                                                 // fill_amount
    itob
    ==
    assert
    // tl:254: assert(Gtxn[end_execute_order_txn_index].ApplicationArgs[3] == itob(index_diff))
    load 33                                                 // end_execute_order_txn_index
    gtxnsa ApplicationArgs 3
    load 28                                                 // index_diff
    itob
    ==
    assert
    
    // Transfer `fill_amount` to executor.
    // tl:257: transfer(order.asset_id, fill_amount, Global.CurrentApplicationAddress, Txn.Sender)
    load 31; pushint 0; pushint 8; box_extract; btoi// order.asset_id
    load 29                                                 // fill_amount
    global CurrentApplicationAddress
    txn Sender
    callsub __func__transfer
    
    // Logs
    // tl:260: log(ARC28Event("start_execute_order(address,uint64,address)", app_global_get(USER_ADDRESS_KEY), itob(order_id), Txn.Sender))
    pushbytes 0x1740bc29                                    // SHA512_256("start_execute_order(address,uint64,address)")[:4]
    pushbytes USER_ADDRESS_KEY                              // "user_address"
    app_global_get
    load 30                                                 // order_id
    itob
    txn Sender
    concat
    concat
    concat
    log
    
    // tl:262: return
    retsub


// Description: Method checks the validity of the execution between `start_execute_order` and `end_execute_order`.
// An executor must return the correct amount of `target_asset_id` via an axfer at `Txn.GroupIndex - 1`. Otherwise the transaction group fails.
// Permission: Everyone
// tl:270: func end_execute_order(order_id: int, fill_amount: int, index_diff: int):
__func__end_execute_order:
    store 34                                                // index_diff [int]
    store 35                                                // fill_amount [int]
    store 36                                                // order_id [int]
    // tl:271: bytes user_address = app_global_get(USER_ADDRESS_KEY) [slot 37]
    pushbytes USER_ADDRESS_KEY                              // "user_address"
    app_global_get
    store 37                                                // user_address
    // tl:272: box<Order> order = OpenBox(Concat("o", itob(order_id))) [slot 38]
    pushbytes "o"
    load 36                                                 // order_id
    itob
    concat
    dup; box_len; assert; pushint 80; ==; assert            // len(box) == Order.size
    store 38                                                // box:order
    
    // tl:274: int start_execute_order_txn_index = Txn.GroupIndex - index_diff [slot 39]
    txn GroupIndex
    load 34                                                 // index_diff
    -
    store 39                                                // start_execute_order_txn_index
    
    // Assertions
    // tl:277: assert(Gtxn[start_execute_order_txn_index].Sender == Txn.Sender)
    load 39                                                 // start_execute_order_txn_index
    gtxns Sender
    txn Sender
    ==
    assert
    // tl:278: assert(Gtxn[start_execute_order_txn_index].TypeEnum == Appl)
    load 39                                                 // start_execute_order_txn_index
    gtxns TypeEnum
    pushint 6                                               // Appl
    ==
    assert
    // tl:279: assert(Gtxn[start_execute_order_txn_index].OnCompletion == NoOp)
    load 39                                                 // start_execute_order_txn_index
    gtxns OnCompletion
    pushint 0                                               // NoOp
    ==
    assert
    // tl:280: assert(Gtxn[start_execute_order_txn_index].ApplicationID == Global.CurrentApplicationID)
    load 39                                                 // start_execute_order_txn_index
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    assert
    // tl:281: assert(Gtxn[start_execute_order_txn_index].ApplicationArgs[0] == "start_execute_order")
    load 39                                                 // start_execute_order_txn_index
    gtxnsa ApplicationArgs 0
    pushbytes "start_execute_order"
    ==
    assert
    // tl:282: assert(Gtxn[start_execute_order_txn_index].ApplicationArgs[1] == itob(order_id))
    load 39                                                 // start_execute_order_txn_index
    gtxnsa ApplicationArgs 1
    load 36                                                 // order_id
    itob
    ==
    assert
    // Parameters `fill_amount` and `index_diff` must be the same.
    // tl:284: assert(Gtxn[start_execute_order_txn_index].ApplicationArgs[2] == itob(fill_amount))
    load 39                                                 // start_execute_order_txn_index
    gtxnsa ApplicationArgs 2
    load 35                                                 // fill_amount
    itob
    ==
    assert
    // tl:285: assert(Gtxn[start_execute_order_txn_index].ApplicationArgs[3] == itob(index_diff))
    load 39                                                 // start_execute_order_txn_index
    gtxnsa ApplicationArgs 3
    load 34                                                 // index_diff
    itob
    ==
    assert
    
    // Assert that user received the target amount or more.
    // TODO: Review the calculations.
    // tl:289: int minimum_amount [slot 40]
    // tl:290: if !order.is_partial_allowed:
    load 38; pushint 48; pushint 8; box_extract; btoi// order.is_partial_allowed
    !
    bz l3_else
    // then:
        // tl:291: minimum_amount = order.target_amount
        load 38; pushint 24; pushint 8; box_extract; btoi// order.target_amount
        store 40                                            // minimum_amount
        b l3_end
    l3_else:
    // tl:292: else:
        // tl:293: minimum_amount = calculate_minimum_amount(order.amount, order.target_amount, fill_amount)
        load 38; pushint 8; pushint 8; box_extract; btoi// order.amount
        load 38; pushint 24; pushint 8; box_extract; btoi// order.target_amount
        load 35                                             // fill_amount
        callsub __func__calculate_minimum_amount
        store 40                                            // minimum_amount
    l3_end:
    
    // tl:296: int received_amount = check_received_target_asset(Txn.GroupIndex - 1, Global.CurrentApplicationAddress, order.target_asset_id, minimum_amount) [slot 41]
    txn GroupIndex
    pushint 1
    -
    global CurrentApplicationAddress
    load 38; pushint 16; pushint 8; box_extract; btoi// order.target_asset_id
    load 40                                                 // minimum_amount
    callsub __func__check_received_target_asset
    store 41                                                // received_amount
    
    // tl:298: order.filled_amount = order.filled_amount + fill_amount
    load 38; pushint 32; pushint 8; box_extract; btoi// order.filled_amount
    load 35                                                 // fill_amount
    +
    itob
    load 38
    pushint 32
    uncover 2
    box_replace
    // boxset order.filled_amount
    // tl:299: order.collected_target_amount = order.collected_target_amount + received_amount
    load 38; pushint 40; pushint 8; box_extract; btoi// order.collected_target_amount
    load 41                                                 // received_amount
    +
    itob
    load 38
    pushint 40
    uncover 2
    box_replace
    // boxset order.collected_target_amount
    
    // Logs
    // tl:302: bytes order_data [slot 42]
    // tl:303: _, order_data = box_get(order)
    load 38                                                 // order
    box_get
    pop                                                     // discarding value for _
    store 42                                                // order_data
    // tl:304: log(ARC28Event("order(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)", user_address, itob(order_id), order_data))
    pushbytes 0xc953e07a                                    // SHA512_256("order(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)")[:4]
    load 37                                                 // user_address
    load 36                                                 // order_id
    itob
    load 42                                                 // order_data
    concat
    concat
    concat
    log
    // tl:305: log(ARC28Event("end_execute_order(address,uint64,address,uint64,uint64)", app_global_get(USER_ADDRESS_KEY), itob(order_id), Txn.Sender, itob(fill_amount), itob(received_amount)))
    pushbytes 0x6cfd21b6                                    // SHA512_256("end_execute_order(address,uint64,address,uint64,uint64)")[:4]
    pushbytes USER_ADDRESS_KEY                              // "user_address"
    app_global_get
    load 36                                                 // order_id
    itob
    txn Sender
    load 35                                                 // fill_amount
    itob
    load 41                                                 // received_amount
    itob
    concat
    concat
    concat
    concat
    concat
    log
    
    // If all amount is filled, send the collected_target_amount to user, send the fee_amount to registry app, delete the order.
    // If partial filling is not allowed `collected_target_amount` >= `target_amount` == `received_amount`.
    // If partial filling is allowed, and user has collected partial fills beforehand, `collected_target_amount` < `target_amount`.
    // tl:310: if order.amount == order.filled_amount:
    load 38; pushint 8; pushint 8; box_extract; btoi// order.amount
    load 38; pushint 32; pushint 8; box_extract; btoi// order.filled_amount
    ==
    bz l4_end
    // then:
        // tl:311: int fee_amount = calculate_fee_amount(order.collected_target_amount, order.fee_rate) [slot 43]
        load 38; pushint 40; pushint 8; box_extract; btoi// order.collected_target_amount
        load 38; pushint 56; pushint 8; box_extract; btoi// order.fee_rate
        callsub __func__calculate_fee_amount
        store 43                                            // fee_amount
        
        // tl:313: transfer(order.target_asset_id, (order.collected_target_amount - fee_amount), Global.CurrentApplicationAddress, user_address)
        load 38; pushint 16; pushint 8; box_extract; btoi// order.target_asset_id
        load 38; pushint 40; pushint 8; box_extract; btoi// order.collected_target_amount
        load 43                                             // fee_amount
        -
        global CurrentApplicationAddress
        load 37                                             // user_address
        callsub __func__transfer
        // tl:314: transfer(order.target_asset_id, fee_amount, Global.CurrentApplicationAddress, app_global_get(REGISTRY_APP_ACCOUNT_ADDRESS_KEY))
        load 38; pushint 16; pushint 8; box_extract; btoi// order.target_asset_id
        load 43                                             // fee_amount
        global CurrentApplicationAddress
        pushbytes REGISTRY_APP_ACCOUNT_ADDRESS_KEY          // "registry_app_account_address"
        app_global_get
        callsub __func__transfer
        // tl:315: _ = box_del(order)
        load 38                                             // order
        box_del
        pop                                                 // discarding value for _
    l4_end:
    
    // tl:318: return
    retsub


// tl:323: func collect(order_id: int):
__func__collect:
    store 44                                                // order_id [int]
    // tl:324: bytes user_address = app_global_get(USER_ADDRESS_KEY) [slot 45]
    pushbytes USER_ADDRESS_KEY                              // "user_address"
    app_global_get
    store 45                                                // user_address
    // tl:325: assert(Txn.Sender == user_address)
    txn Sender
    load 45                                                 // user_address
    ==
    assert
    // tl:326: box<Order> order = OpenBox(Concat("o", itob(order_id))) [slot 46]
    pushbytes "o"
    load 44                                                 // order_id
    itob
    concat
    dup; box_len; assert; pushint 80; ==; assert            // len(box) == Order.size
    store 46                                                // box:order
    
    // tl:328: assert(order.collected_target_amount)
    load 46; pushint 40; pushint 8; box_extract; btoi// order.collected_target_amount
    assert
    
    // tl:330: int fee_amount = calculate_fee_amount(order.collected_target_amount, order.fee_rate) [slot 47]
    load 46; pushint 40; pushint 8; box_extract; btoi// order.collected_target_amount
    load 46; pushint 56; pushint 8; box_extract; btoi// order.fee_rate
    callsub __func__calculate_fee_amount
    store 47                                                // fee_amount
    // tl:331: assert(fee_amount)
    load 47                                                 // fee_amount
    assert
    
    // tl:333: transfer(order.target_asset_id, (order.collected_target_amount - fee_amount), Global.CurrentApplicationAddress, user_address)
    load 46; pushint 16; pushint 8; box_extract; btoi// order.target_asset_id
    load 46; pushint 40; pushint 8; box_extract; btoi// order.collected_target_amount
    load 47                                                 // fee_amount
    -
    global CurrentApplicationAddress
    load 45                                                 // user_address
    callsub __func__transfer
    // tl:334: transfer(order.target_asset_id, fee_amount, Global.CurrentApplicationAddress, app_global_get(REGISTRY_APP_ACCOUNT_ADDRESS_KEY))
    load 46; pushint 16; pushint 8; box_extract; btoi// order.target_asset_id
    load 47                                                 // fee_amount
    global CurrentApplicationAddress
    pushbytes REGISTRY_APP_ACCOUNT_ADDRESS_KEY              // "registry_app_account_address"
    app_global_get
    callsub __func__transfer
    
    // tl:336: int collected_target_amount = order.collected_target_amount [slot 48]
    load 46; pushint 40; pushint 8; box_extract; btoi// order.collected_target_amount
    store 48                                                // collected_target_amount
    // tl:337: order.collected_target_amount = 0
    pushint 0
    itob
    load 46
    pushint 40
    uncover 2
    box_replace
    // boxset order.collected_target_amount
    
    // Logs
    // tl:340: bytes order_data [slot 49]
    // tl:341: _, order_data = box_get(order)
    load 46                                                 // order
    box_get
    pop                                                     // discarding value for _
    store 49                                                // order_data
    // tl:342: log(ARC28Event("order(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)", user_address, itob(order_id), order_data))
    pushbytes 0xc953e07a                                    // SHA512_256("order(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)")[:4]
    load 45                                                 // user_address
    load 44                                                 // order_id
    itob
    load 49                                                 // order_data
    concat
    concat
    concat
    log
    // tl:343: log(ARC28Event("collect(uint64,uint64)", itob(order_id), itob(collected_target_amount)))
    pushbytes 0x2a061e2b                                    // SHA512_256("collect(uint64,uint64)")[:4]
    load 44                                                 // order_id
    itob
    load 48                                                 // collected_target_amount
    itob
    concat
    concat
    log
    
    // tl:345: return
    retsub


// tl:349: func calculate_minimum_amount(amount: int, target_amount: int, fill_amount: int) int:
__func__calculate_minimum_amount:
    store 50                                                // fill_amount [int]
    store 51                                                // target_amount [int]
    store 52                                                // amount [int]
    // tl:350: bytes target_rate = (itob(target_amount) b* itob(RATE_SCALER)) b/ itob(amount) [slot 53]
    load 51                                                 // target_amount
    itob
    pushint RATE_SCALER                                     // 18446744073709551615
    itob
    b*
    load 52                                                 // amount
    itob
    b/
    store 53                                                // target_rate
    // tl:351: int minimum_amount = btoi((itob(fill_amount) b* target_rate) b/ itob(RATE_SCALER)) [slot 54]
    load 50                                                 // fill_amount
    itob
    load 53                                                 // target_rate
    b*
    pushint RATE_SCALER                                     // 18446744073709551615
    itob
    b/
    btoi
    store 54                                                // minimum_amount
    // tl:352: return minimum_amount
    load 54                                                 // minimum_amount
    retsub


// tl:356: func calculate_fee_amount(target_amount: int, fee_rate: int) int:
__func__calculate_fee_amount:
    store 55                                                // fee_rate [int]
    store 56                                                // target_amount [int]
    // tl:357: int fee_amount = (target_amount * fee_rate) / 10000 [slot 57]
    load 56                                                 // target_amount
    load 55                                                 // fee_rate
    *
    pushint 10000
    /
    store 57                                                // fee_amount
    // tl:358: return fee_amount
    load 57                                                 // fee_amount
    retsub


// tl:362: func get_fee_rate() int:
__func__get_fee_rate:
    // tl:363: bytes threshold_bytes [slot 58]
    // tl:364: bytes fee_rate_bytes [slot 59]
    // tl:365: int fee_rate [slot 60]
    
    // tl:367: int account_voting_power = get_account_voting_power(UncheckedCast(app_global_get(USER_ADDRESS_KEY), bytes)) [slot 61]
    pushbytes USER_ADDRESS_KEY                              // "user_address"
    app_global_get
    callsub __func__get_account_voting_power
    store 61                                                // account_voting_power
    // tl:368: _, threshold_bytes = app_global_get_ex(app_global_get(REGISTRY_APP_ID_KEY), GOVERNOR_FEE_RATE_POWER_THRESHOLD)
    pushbytes REGISTRY_APP_ID_KEY                           // "registry_app_id"
    app_global_get
    pushbytes GOVERNOR_FEE_RATE_POWER_THRESHOLD             // "governor_fee_rate_power_threshold"
    app_global_get_ex
    pop                                                     // discarding value for _
    store 58                                                // threshold_bytes
    // tl:369: int fee_rate_power_threshold = UncheckedCast(threshold_bytes, int) [slot 62]
    load 58                                                 // threshold_bytes
    store 62                                                // fee_rate_power_threshold
    
    // tl:371: if account_voting_power > fee_rate_power_threshold:
    load 61                                                 // account_voting_power
    load 62                                                 // fee_rate_power_threshold
    >
    bz l5_else
    // then:
        // tl:372: _, fee_rate_bytes = app_global_get_ex(app_global_get(REGISTRY_APP_ID_KEY), GOVERNOR_ORDER_FEE_RATE_KEY)
        pushbytes REGISTRY_APP_ID_KEY                       // "registry_app_id"
        app_global_get
        pushbytes GOVERNOR_ORDER_FEE_RATE_KEY               // "governor_order_fee_rate"
        app_global_get_ex
        pop                                                 // discarding value for _
        store 59                                            // fee_rate_bytes
        b l5_end
    l5_else:
    // tl:373: else:
        // tl:374: _, fee_rate_bytes = app_global_get_ex(app_global_get(REGISTRY_APP_ID_KEY), ORDER_FEE_RATE_KEY)
        pushbytes REGISTRY_APP_ID_KEY                       // "registry_app_id"
        app_global_get
        pushbytes ORDER_FEE_RATE_KEY                        // "order_fee_rate"
        app_global_get_ex
        pop                                                 // discarding value for _
        store 59                                            // fee_rate_bytes
    l5_end:
    
    // tl:377: fee_rate = UncheckedCast(fee_rate_bytes, int)
    load 59                                                 // fee_rate_bytes
    store 60                                                // fee_rate
    // tl:378: return fee_rate
    load 60                                                 // fee_rate
    retsub


// tl:382: func get_account_voting_power(address: bytes) int:
__func__get_account_voting_power:
    store 63                                                // address [bytes]
    // tl:383: inner_txn:
    itxn_begin
        // tl:384: TypeEnum: Appl
        pushint 6                                           // Appl
        itxn_field TypeEnum
        // tl:385: ApplicationID: app_global_get(VAULT_APP_ID_KEY)
        pushbytes VAULT_APP_ID_KEY                          // "vault_app_id"
        app_global_get
        itxn_field ApplicationID
        // tl:386: ApplicationArgs[0]: "get_tiny_power_of"
        pushbytes "get_tiny_power_of"
        itxn_field ApplicationArgs
        // tl:387: ApplicationArgs[1]: address
        load 63                                             // address
        itxn_field ApplicationArgs
        // tl:388: Fee: 0
        pushint 0
        itxn_field Fee
    itxn_submit
    // end inner_txn
    // tl:390: int voting_power = extract_uint64(Itxn.LastLog, 4) [slot 64]
    itxn LastLog
    pushint 4
    extract_uint64
    store 64                                                // voting_power
    // tl:391: return voting_power
    load 64                                                 // voting_power
    retsub


// tl:395: func opt_in_to_asset_if_needed(asset_id: int):
__func__opt_in_to_asset_if_needed:
    store 65                                                // asset_id [int]
    // tl:396: if asset_id:
    load 65                                                 // asset_id
    bz l6_end
    // then:
        // tl:397: int is_opted_in [slot 66]
        // tl:398: is_opted_in, _ = asset_holding_get(AssetBalance, Global.CurrentApplicationAddress, asset_id)
        global CurrentApplicationAddress
        load 65                                             // asset_id
        asset_holding_get AssetBalance
        store 66                                            // is_opted_in
        pop                                                 // discarding value for _
        
        // tl:400: if is_opted_in == 0:
        load 66                                             // is_opted_in
        pushint 0
        ==
        bz l7_end
        // then:
            // tl:401: transfer(asset_id, 0, Global.CurrentApplicationAddress, Global.CurrentApplicationAddress)
            load 65                                         // asset_id
            pushint 0
            global CurrentApplicationAddress
            global CurrentApplicationAddress
            callsub __func__transfer
        l7_end:
    l6_end:
    // tl:404: return
    retsub


// tl:408: func check_received_asset(txn_index: int, receiver: bytes, asset_id: int, amount: int):
__func__check_received_asset:
    store 67                                                // amount [int]
    store 68                                                // asset_id [int]
    store 69                                                // receiver [bytes]
    store 70                                                // txn_index [int]
    // tl:409: if !asset_id:
    load 68                                                 // asset_id
    !
    bz l8_else
    // then:
        // tl:410: assert(Gtxn[txn_index].TypeEnum == Pay)
        load 70                                             // txn_index
        gtxns TypeEnum
        pushint 1                                           // Pay
        ==
        assert
        // tl:411: assert(Gtxn[txn_index].Receiver == receiver)
        load 70                                             // txn_index
        gtxns Receiver
        load 69                                             // receiver
        ==
        assert
        // tl:412: assert(Gtxn[txn_index].Amount == amount)
        load 70                                             // txn_index
        gtxns Amount
        load 67                                             // amount
        ==
        assert
        b l8_end
    l8_else:
    // tl:413: else:
        // tl:414: assert(Gtxn[txn_index].TypeEnum == Axfer)
        load 70                                             // txn_index
        gtxns TypeEnum
        pushint 4                                           // Axfer
        ==
        assert
        // tl:415: assert(Gtxn[txn_index].AssetReceiver == receiver)
        load 70                                             // txn_index
        gtxns AssetReceiver
        load 69                                             // receiver
        ==
        assert
        // tl:416: assert(Gtxn[txn_index].XferAsset == asset_id)
        load 70                                             // txn_index
        gtxns XferAsset
        load 68                                             // asset_id
        ==
        assert
        // tl:417: assert(Gtxn[txn_index].AssetAmount == amount)
        load 70                                             // txn_index
        gtxns AssetAmount
        load 67                                             // amount
        ==
        assert
    l8_end:
    // tl:419: return
    retsub


// tl:423: func check_received_target_asset(txn_index: int, receiver: bytes, asset_id: int, minimum_amount: int) int:
__func__check_received_target_asset:
    store 71                                                // minimum_amount [int]
    store 72                                                // asset_id [int]
    store 73                                                // receiver [bytes]
    store 74                                                // txn_index [int]
    // tl:424: int received_amount [slot 75]
    // tl:425: if !asset_id:
    load 72                                                 // asset_id
    !
    bz l9_else
    // then:
        // tl:426: assert(Gtxn[txn_index].TypeEnum == Pay)
        load 74                                             // txn_index
        gtxns TypeEnum
        pushint 1                                           // Pay
        ==
        assert
        // tl:427: assert(Gtxn[txn_index].Receiver == receiver)
        load 74                                             // txn_index
        gtxns Receiver
        load 73                                             // receiver
        ==
        assert
        // tl:428: assert(Gtxn[txn_index].Amount >= minimum_amount)
        load 74                                             // txn_index
        gtxns Amount
        load 71                                             // minimum_amount
        >=
        assert
        
        // tl:430: received_amount = Gtxn[txn_index].Amount
        load 74                                             // txn_index
        gtxns Amount
        store 75                                            // received_amount
        b l9_end
    l9_else:
    // tl:431: else:
        // tl:432: assert(Gtxn[txn_index].TypeEnum == Axfer)
        load 74                                             // txn_index
        gtxns TypeEnum
        pushint 4                                           // Axfer
        ==
        assert
        // tl:433: assert(Gtxn[txn_index].AssetReceiver == receiver)
        load 74                                             // txn_index
        gtxns AssetReceiver
        load 73                                             // receiver
        ==
        assert
        // tl:434: assert(Gtxn[txn_index].XferAsset == asset_id)
        load 74                                             // txn_index
        gtxns XferAsset
        load 72                                             // asset_id
        ==
        assert
        // tl:435: assert(Gtxn[txn_index].AssetAmount >= minimum_amount)
        load 74                                             // txn_index
        gtxns AssetAmount
        load 71                                             // minimum_amount
        >=
        assert
        
        // tl:437: received_amount = Gtxn[txn_index].AssetAmount
        load 74                                             // txn_index
        gtxns AssetAmount
        store 75                                            // received_amount
    l9_end:
    
    // tl:440: return received_amount
    load 75                                                 // received_amount
    retsub


// tl:444: func transfer(asset_id: int, amount: int, sender: bytes, receiver: bytes):
__func__transfer:
    store 76                                                // receiver [bytes]
    store 77                                                // sender [bytes]
    store 78                                                // amount [int]
    store 79                                                // asset_id [int]
    // tl:445: if !asset_id:
    load 79                                                 // asset_id
    !
    bz l10_else
    // then:
        // tl:446: inner_txn:
        itxn_begin
            // tl:447: TypeEnum: Pay
            pushint 1                                       // Pay
            itxn_field TypeEnum
            // tl:448: Sender: sender
            load 77                                         // sender
            itxn_field Sender
            // tl:449: Receiver: receiver
            load 76                                         // receiver
            itxn_field Receiver
            // tl:450: Amount: amount
            load 78                                         // amount
            itxn_field Amount
            // tl:451: Fee: 0
            pushint 0
            itxn_field Fee
        itxn_submit
        // end inner_txn
        b l10_end
    l10_else:
    // tl:453: else:
        // tl:454: inner_txn:
        itxn_begin
            // tl:455: TypeEnum: Axfer
            pushint 4                                       // Axfer
            itxn_field TypeEnum
            // tl:456: Sender: sender
            load 77                                         // sender
            itxn_field Sender
            // tl:457: AssetReceiver: receiver
            load 76                                         // receiver
            itxn_field AssetReceiver
            // tl:458: AssetAmount: amount
            load 78                                         // amount
            itxn_field AssetAmount
            // tl:459: XferAsset: asset_id
            load 79                                         // asset_id
            itxn_field XferAsset
            // tl:460: Fee: 0
            pushint 0
            itxn_field Fee
        itxn_submit
        // end inner_txn
    l10_end:
    // tl:463: return
    retsub


